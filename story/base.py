from dataclasses import field

import story.utils
from story.character import Character
from story.playobject import Choice
from story.scene import Scene


class Story:
    original_text = ""  # store the original story text
    summary = ""  # summary of the original story text, generated by LLM
    element = ""  # element of the original story text, generated by LLM

    character: Character = None

    scenes: list[Scene] = field(default_factory=list)
    current_scene_index = 0

    def __init__(self, story_text: str = ""):
        if story_text != "":
            self.original_text = story_text

        # initialize the scenes list
        self.scenes = []

    def play(self):

        scene = self.scenes[self.current_scene_index]

        # display the character if it is the first scene
        if self.current_scene_index == 0 and scene.current_playing_index == 0:
            self.character.display()

        # play current scene
        scene.play()

    def receive_input(self, input_str: str) -> bool:
        """
        Receive input from the user
        """
        # get the current scene
        current_scene = self.scenes[self.current_scene_index]

        # get the last play object
        last_play_object = current_scene.sequence[current_scene.current_playing_index - 1]

        # if the last play object is a Choice object
        if isinstance(last_play_object, Choice):

            # if choice is neither 'q' nor an integer, prompt for choice again
            while input_str != 'q' and not input_str.isdigit():
                input_str = input("Your input should be an integer from 1 to 3, or 'q', please try again: ")

            # if choice is 'q', quit the game
            if input_str == 'q':
                return False
            else:
                # get the choice index
                choice_index = int(input_str)
                # generate a new scene from the choice
                self.generate_scene_from_choice(choice_index)
                # play the new scene
                self.play()
                return True
        else:
            self.play()
            return True

    def init_understand(self):
        """
        Initialize the story by understanding the story text.
        Generally, this function will identify the character, character description, and choices in the story.
        And construct initial scenes using choices.
        """
        # Get the answer dictionary from the first run QA
        answer_dict = story.utils.first_run_qa(self.original_text)

        # get basic info of the story
        self.summary = answer_dict['summary']
        self.element = answer_dict['element']

        # construct the character by parsing the answer dictionary
        self.character = Character(answer_dict)

        # construct scenes
        # but skip constructing the first scene
        # only construct the second scene
        new_scene = Scene(
            last_choice=answer_dict['action1'],
            history_scene_index_list=[self.current_scene_index],
            story_clip=answer_dict['clip1'],
            choice=Choice([answer_dict['action2'], answer_dict['alternative3'], answer_dict['alternative4']]),
            character=self.character
        )
        self.scenes.append(new_scene)

    def generate_scene_from_choice(self, choice_index: int):
        """
        Generate a new scene from the choice made by the user
        """
        current_scene = self.scenes[self.current_scene_index]
        last_play_object = current_scene.sequence[-1]
        if not isinstance(last_play_object, Choice):
            raise ValueError("Last play object is not a Choice object!")
        else:
            current_choices: Choice = last_play_object
            choice = current_choices.content[choice_index - 1]

            # iterate through the scenes list to find the scene with the last choice
            for scene in self.scenes:
                if scene.last_choice == choice:
                    self.current_scene_index = self.scenes.index(scene)
                    return None

            # if the scene with the last choice is not found, generate a new scene
            print("Generating new story...")

            # get history stories by combining the latest 10 history scene summaries from the history scene index list
            history_stories = ""
            for index in current_scene.history_scene_indices[-min(10, len(current_scene.history_scene_indices)):]:
                history_stories += self.scenes[index].story_clip + " "
            # add current scene story clip to history stories
            history_stories += current_scene.story_clip

            # prompt for story generation
            # TODO: summarize the earliest 10 history scenes
            # TODO: reflect the character personality from history and update it
            answer_dict = story.utils.later_run_qa(
                history_stories, choice, self.character, self.element)

            # configure the new scene
            history_indices = current_scene.history_scene_indices.copy()
            history_indices.append(self.current_scene_index)
            new_scene = Scene(
                last_choice=choice,
                history_scene_index_list=history_indices,
                story_clip=answer_dict['clip'],
                choice=Choice([answer_dict['action'], answer_dict['alternative1'], answer_dict['alternative2']]),
                character=self.character
            )
            self.scenes.append(new_scene)
            self.current_scene_index = self.scenes.index(new_scene)
